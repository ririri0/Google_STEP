# Homework 7

## 宿題1
次のような実行時間順になると推測した。  
早い < (i-k-j) < (k-i-j) < (i-j-k) < (j-i-k) < (k-j-i) < (j-k-i) < 遅い  

(i-k-j)はどの行列も連続してメモリにアクセスしているため一番早く、(j-k-i)はどの行列も連続してメモリにアクセスできていない(参照しているメモリが同じ場合は除く)ため一番遅いと考えた。  
次に、(i-j-k)と(k-i-j)が連続してメモリにアクセスしていない行列がresult, matrix1, matrix2のうち1種類になるため早いと考えた。(i-j-k)はkが内側で回っている間、matrix2は連続したメモリからデータを取得できず、それに比べて(k-i-j)は、matrix1.at(i).at(k)が連続アクセスではないが、一番内側のループではないので、非連続アクセスを毎回は行なっていない。そのため(k-i-j) < (i-j-k)であると考えた。  
(k-j-i)については、一番内側のループでmatrix1とresultが毎回飛び飛びのアドレスからデータを取得することになってしまっていて、(j-i-k)については、一番内側のループによって非連続アクセスになっているのはmatrix1だけである。したがって、(j-i-k) < (k-j-i)であると考えた。  


キャッシュライン衝突による非効率化をなるべく避けるために行列の大きさN=1023で試行した。  
かけ算を行う2つの行列には、10以下の値をランダムに格納した。  
行列積を計算する関数が実行している時間のみを計測して出力するプログラムmatrix.cppを用いた。出力は単位が秒の値をdouble型で出力する。  
最適化を行わなかった実行に比べると、いずれの最適化も実行時間を大幅に短縮できた。  
-O最適化と-O2最適化は今回の場合あまり変わらなかった。また、-O3最適化の方が実行時間が多い結果となった。必ずしも最適化の強度を強くすることが良い結果をもたらすわけではないことが確認できた。  
予想は、(i-j-k)と(k-i-j)については誤差以上に実行時間が逆転している結果となった。  
これは、一番内側のループで、(k-i-j)はresultとmatrix2で連続アクセスができていて、(i-j-k)はmatrix1のみ連続アクセスとなっているのが原因と考えられる。  
また、(i-k-j) と (k-i-j）、(k-j-i) と (j-k-i)については有意な差が出なかった。  
これは、(i-k-j) と (k-i-j）において、一番内側のループによって2種類の行列に連続アクセスしている点は変わらず、また、(k-j-i) と (j-k-i)についても一番内側のループによって2種類の行列に非連続アクセスしている点が変わらないからではないかと推測する。


表1　最適化を行わず、matrix.cppを実行した結果
|       | 1回目/s   | 2回目/s   | 3回目/s   | average/s | 
| ----- | ------- | ------- | ------- | ------- | 
| i-k-j | 4.1515  | 4.1728  | 4.1203  | 4.1482  | 
| k-i-j | 4.2653  | 4.2399  | 4.2593  | 4.2548  | 
| i-j-k | 7.5931  | 8.0655  | 7.7601  | 7.8062  | 
| j-i-k | 5.1731  | 5.1594  | 5.1277  | 5.1534  | 
| k-j-i | 10.5290 | 10.9784 | 10.6168 | 10.7081 | 
| j-k-i | 10.3336 | 10.6369 | 11.1314 | 10.7006 | 



表2 -O最適化を行なってmatrix.cppを実行した結果
|       | 1回目/s    | 2回目/s    | 3回目/s    | average/s    | 
| ----- | -------- | -------- | -------- | ---------- | 
| i-k-j | 0.379417 | 0.397556 | 0.371689 | 0.38288733 | 
| k-i-j | 0.509524 | 0.561386 | 0.540111 | 0.53700700 | 
| i-j-k | 2.19893  | 2.2165   | 2.40202  | 2.27248333 | 
| j-i-k | 1.33283  | 1.35738  | 1.35164  | 1.34728333 | 
| k-j-i | 6.12854  | 6.34062  | 6.26723  | 6.24546333 | 
| j-k-i | 6.18586  | 6.22434  | 6.27466  | 6.22828667 | 



表3 -O2最適化を行なってmatrix.cppを実行した結果
|       | 1回目/s  | 2回目/s  | 3回目/s  | average/s | 
| ----- | -------- | -------- | -------- | --------- | 
| i-k-j | 0.370579 | 0.369342 | 0.397825 | 0.37925   | 
| k-i-j | 0.51907  | 0.501253 | 0.506583 | 0.50897   | 
| i-j-k | 2.69183  | 2.20328  | 2.77799  | 2.55770   | 
| j-i-k | 1.32314  | 1.31347  | 1.34795  | 1.32819   | 
| k-j-i | 6.19122  | 6.12111  | 6.08744  | 6.13326   | 
| j-k-i | 6.25965  | 6.24378  | 6.37498  | 6.29280   | 



表4 -O3最適化を行なってmatrix.cppを実行した結果
|       | 1回目/s  | 2回目/s  | 3回目/s  | average/s | 
| ----- | -------- | -------- | -------- | --------- | 
| i-k-j | 0.402464 | 0.370924 | 0.466512 | 0.41330   | 
| k-i-j | 0.529376 | 0.525896 | 0.5673   | 0.54086   | 
| i-j-k | 2.61944  | 2.23911  | 2.23196  | 2.36350   | 
| j-i-k | 1.35978  | 1.35203  | 1.33709  | 1.34963   | 
| k-j-i | 6.18736  | 6.24299  | 6.17794  | 6.20276   | 
| j-k-i | 6.45262  | 6.33779  | 6.18344  | 6.32462   | 



C++のstd::vectorを使ったvector_matrix.cppでも試行した。これは行列積の計算の関数にmatrix.cppのようにポインタ渡しをしていないが、なるべく条件を一致させるためvoid型の関数で配列は返さずに行列積の計算のみを行うような関数にした。  
vectorではキャッシュライン衝突(N=2^m(mは環境によって異なる整数)でキャッシュの効率が下がってしまい実行時間がN=2^mの前後に比べて大幅に実行時間がかかってしまう現象)が起こらなかった。しかし、参照の局所性は見受けられる結果となった。最適化によって局所性的な効率が良い場合は大幅に実行時間が減少した。局所性的な効率が良くない場合にも実行時間はかなり減少した。  
連続した領域を確保していないため、データが格納されているメモリのアドレスから計算してキャッシュ格納を行う現象に対しては効率化ができているのではないかと推測する。  
最適化を行なってもただの配列を用いているmatrix1.cppの方が実行時間は大幅に少ない。ポインタをまたいでデータにアクセスすることはアクセス時間が大幅にかかってしまうため非効率であると確認できた。


表5 最適化を行わずvector_matrix.cppを実行した結果
|       | 1回目/s | 2回目/s | 3回目/s | average/s | 
| ----- | ------- | ------- | ------- | --------- | 
| i-k-j | 74.0273 | 73.8475 | 74.7852 | 74.22000  | 
| k-i-j | 74.8646 | 74.3807 | 74.3024 | 74.51590  | 
| i-j-k | 104.899 | 102.639 | 109.639 | 105.72567 | 
| j-i-k | 108.229 | 104.899 | 102.639 | 105.25567 | 
| k-j-i | 138.958 | 146.846 | 147.695 | 144.49967 | 
| j-k-i | 133.165 | 133.508 | 137.262 | 134.64500 | 



表6 -O3最適化でvector_matrix.cppを実行した結果
|       | 1回目/s   | 2回目/s   | 3回目/s   | average/s  | 
| ----- | ------- | ------- | ------- | -------- | 
| i-k-j | 2.15918 | 2.14259 | 2.13083 | 2.14420  | 
| k-i-j | 2.20042 | 2.3497  | 2.26727 | 2.27246  | 
| i-j-k | 23.9777 | 21.7849 | 21.1076 | 22.29007 | 
| j-i-k | 19.7394 | 20.4224 | 22.4849 | 20.88223 | 
| k-j-i | 40.9883 | 38.9153 | 36.0801 | 38.66123 | 
| j-k-i | 37.4109 | 37.9446 | 37.6479 | 37.66780 | 





## 宿題2
Pythonの配列は、メモリ上で連続した領域を確保しているわけではないため、局所性を利用した効率化ができていないのではないかと考える。データが格納されているメモリを指しているポインタを所持しており、よって参照の局所性の恩恵を受けられない。  
しかし、似たような構造をしているC++のstd::vectorでは局所性の傾向は存在していた。よって、Pythonがインタプリタ言語でC/C++がコンパイラ言語という違いに起因する原因もあるのではないかと考える。

